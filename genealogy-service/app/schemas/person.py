import uuid
from datetime import datetime
from typing import List, Optional, Any

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument  # For find_one_and_update
from pydantic import BaseModel

from app.models_main import Person, PersonCreate
from app.db.base import PERSONS_COLLECTION

# Define PersonRead, PersonList, and PersonSummary schemas for API


class PersonRead(Person):
    class Config:
        from_attributes = True


class PersonSummary(BaseModel):
    id: uuid.UUID
    primary_name: Any  # Could be PersonName, but for summary, keep it simple
    gender: str
    is_living: bool
    birth_date_string: Optional[str] = None
    death_date_string: Optional[str] = None


class PersonList(BaseModel):
    items: List[PersonRead]
    total: int


class PersonUpdate(BaseModel):
    primary_name: Optional[dict] = None
    gender: Optional[str] = None
    birth_date_string: Optional[str] = None
    birth_date_exact: Optional[str] = None
    birth_place: Optional[str] = None
    is_birth_date_estimated: Optional[bool] = None
    death_date_string: Optional[str] = None
    death_date_exact: Optional[str] = None
    death_place: Optional[str] = None
    is_death_date_estimated: Optional[bool] = None
    cause_of_death: Optional[str] = None
    is_living: Optional[bool] = None
    biography: Optional[str] = None
    notes: Optional[str] = None
    profile_image_id: Optional[uuid.UUID] = None
    clan: Optional[str] = None
    tribe: Optional[str] = None
    traditional_titles: Optional[List[str]] = None
    privacy_settings: Optional[dict] = None
    facts: Optional[List[dict]] = None
    identifiers: Optional[List[dict]] = None

    class Config:
        extra = "allow"


async def create_person(
    db: AsyncIOMotorDatabase, *, person_in: PersonCreate, creator_user_id: str
) -> Person:
    """
    Create a new person.
    `creator_user_id` might be used for auditing or initial ownership if applicable,
    though persons are primarily tied to trees.
    """
    collection = db[PERSONS_COLLECTION]
    now = datetime.utcnow()

    # Note: PersonCreate might not have all fields of Person (like id, created_at, updated_at)
    # These are handled by DBModelMixin or set here.
    db_person = Person(
        **person_in.model_dump(exclude_unset=True),  # Use exclude_unset for optional fields
        created_at=now,
        updated_at=now
        # id is generated by default_factory
        # tree_ids must be provided in person_in
    )

    # Ensure primary_name is set if not provided but individual names are
    if not db_person.primary_name.given_name and not db_person.primary_name.surname:
        if person_in.primary_name.given_name or person_in.primary_name.surname:  # Check original input
            db_person.primary_name = person_in.primary_name
        # else: handle error or default name if required by business logic

    await collection.insert_one(db_person.model_dump(by_alias=True))
    return db_person


async def get_person_by_id(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID) -> Optional[Person]:
    """
    Get a person by their ID.
    Privacy/tree access checks should be done at the service/API layer.
    """
    collection = db[PERSONS_COLLECTION]
    doc = await collection.find_one({"_id": person_id})
    return Person(**doc) if doc else None


async def get_persons_by_tree_id(
    db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, skip: int = 0, limit: int = 1000
) -> List[Person]:
    """
    Get all persons belonging to a specific family tree.
    """
    collection = db[PERSONS_COLLECTION]
    persons = []
    # Query for persons where the tree_id is in their tree_ids list
    cursor = collection.find({"tree_ids": tree_id}).skip(skip).limit(limit)
    async for doc in cursor:
        persons.append(Person(**doc))
    return persons


async def update_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, person_in: PersonUpdate  # PersonUpdate schema to be defined
) -> Optional[Person]:
    """
    Update an existing person.
    Access control (e.g., user can edit this person) should be checked before calling this.
    """
    collection = db[PERSONS_COLLECTION]

    update_data = person_in.model_dump(exclude_unset=True)
    if not update_data:
        return await get_person_by_id(db, person_id=person_id)  # No changes

    update_data["updated_at"] = datetime.utcnow()

    # If primary_name fields are being updated individually, ensure the PersonName object is updated.
    # This might require more complex logic if person_in.primary_name is an object itself.
    # For simplicity, assume direct field updates or full primary_name object replacement.
    # Example for nested update if primary_name fields are flat in PersonUpdate:
    # primary_name_update = {}
    # if "primary_name_given_name" in update_data:
    #     primary_name_update["primary_name.given_name"] = update_data.pop("primary_name_given_name")
    # ... and so on for other primary_name fields.
    # if primary_name_update:
    #     update_query["$set"].update(primary_name_update)

    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$set": update_data},
        return_document=ReturnDocument.AFTER,  # Make sure to import ReturnDocument
    )
    return Person(**updated_doc) if updated_doc else None


async def delete_person(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID) -> bool:
    """
    Delete a person by their ID.
    This is a hard delete. Consider implications:
    - Relationships involving this person.
    - Events linked to this person.
    - Unlinking from family trees vs. deleting if no longer in any tree.
    Application logic needs to handle these cascading effects.
    """
    collection = db[PERSONS_COLLECTION]
    result = await collection.delete_one({"_id": person_id})

    if result.deleted_count > 0:
        # TODO: Trigger cleanup of related data (relationships, events, history, unlinking from trees)
        # This could be done via events/ Celery tasks.
        return True
    return False


async def add_person_to_tree(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID
) -> Optional[Person]:
    """Adds a person to a family tree by adding the tree_id to their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$addToSet": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}},  # $addToSet prevents duplicates
        return_document=ReturnDocument.AFTER,
    )
    return Person(**updated_doc) if updated_doc else None


async def remove_person_from_tree(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID
) -> Optional[Person]:
    """Removes a person from a family tree by removing the tree_id from their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$pull": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}},
        return_document=ReturnDocument.AFTER,
    )
    # After removing, if person.tree_ids is empty, should the person be deleted?
    # This depends on application requirements. For now, just unlinks.
    return Person(**updated_doc) if updated_doc else None


# TODO:
# - Search/filter persons (e.g., by name, dates within a tree)
# - Count persons in a tree
# - Functions for managing facts, identifiers, privacy_settings if they are complex sub-updates.
# - Handling of PersonHistory creation upon updates.
# - CRUD for Person's potential_duplicates, merged_into_id, merged_from_ids.
