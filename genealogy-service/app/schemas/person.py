import uuid
from datetime import datetime
from typing import List, Optional, Dict, Any

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument # For find_one_and_update

from app.models import Person # DB Model
from app.schemas import PersonCreate, PersonUpdate # API Schemas (PersonUpdate to be created)
from app.db.base import PERSONS_COLLECTION

async def create_person(db: AsyncIOMotorDatabase, *, person_in: PersonCreate, creator_user_id: str) -> Person:
    """
    Create a new person.
    `creator_user_id` might be used for auditing or initial ownership if applicable,
    though persons are primarily tied to trees.
    """
    collection = db[PERSONS_COLLECTION]
    now = datetime.utcnow()

    # Note: PersonCreate might not have all fields of Person (like id, created_at, updated_at)
    # These are handled by DBModelMixin or set here.
    db_person = Person(
        **person_in.model_dump(exclude_unset=True), # Use exclude_unset for optional fields
        created_at=now,
        updated_at=now
        # id is generated by default_factory
        # tree_ids must be provided in person_in
    )

    # Ensure primary_name is set if not provided but individual names are
    if not db_person.primary_name.given_name and not db_person.primary_name.surname:
        if person_in.primary_name.given_name or person_in.primary_name.surname: # Check original input
            db_person.primary_name = person_in.primary_name
        # else: handle error or default name if required by business logic

    await collection.insert_one(db_person.model_dump(by_alias=True))
    return db_person

async def get_person_by_id(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID) -> Optional[Person]:
    """
    Get a person by their ID.
    Privacy/tree access checks should be done at the service/API layer.
    """
    collection = db[PERSONS_COLLECTION]
    doc = await collection.find_one({"_id": person_id})
    return Person(**doc) if doc else None

async def get_persons_by_tree_id(
    db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, skip: int = 0, limit: int = 1000
) -> List[Person]:
    """
    Get all persons belonging to a specific family tree.
    """
    collection = db[PERSONS_COLLECTION]
    persons = []
    # Query for persons where the tree_id is in their tree_ids list
    cursor = collection.find({"tree_ids": tree_id}).skip(skip).limit(limit)
    async for doc in cursor:
        persons.append(Person(**doc))
    return persons

async def update_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, person_in: PersonUpdate # PersonUpdate schema to be defined
) -> Optional[Person]:
    """
    Update an existing person.
    Access control (e.g., user can edit this person) should be checked before calling this.
    """
    collection = db[PERSONS_COLLECTION]

    update_data = person_in.model_dump(exclude_unset=True)
    if not update_data:
        return await get_person_by_id(db, person_id=person_id) # No changes

    update_data["updated_at"] = datetime.utcnow()

    # If primary_name fields are being updated individually, ensure the PersonName object is updated.
    # This might require more complex logic if person_in.primary_name is an object itself.
    # For simplicity, assume direct field updates or full primary_name object replacement.
    # Example for nested update if primary_name fields are flat in PersonUpdate:
    # primary_name_update = {}
    # if "primary_name_given_name" in update_data:
    #     primary_name_update["primary_name.given_name"] = update_data.pop("primary_name_given_name")
    # ... and so on for other primary_name fields.
    # if primary_name_update:
    #     update_query["$set"].update(primary_name_update)

    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$set": update_data},
        return_document=ReturnDocument.AFTER # Make sure to import ReturnDocument
    )
    return Person(**updated_doc) if updated_doc else None

async def delete_person(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID) -> bool:
    """
    Delete a person by their ID.
    This is a hard delete. Consider implications:
    - Relationships involving this person.
    - Events linked to this person.
    - Unlinking from family trees vs. deleting if no longer in any tree.
    Application logic needs to handle these cascading effects.
    """
    collection = db[PERSONS_COLLECTION]
    result = await collection.delete_one({"_id": person_id})

    if result.deleted_count > 0:
        # TODO: Trigger cleanup of related data (relationships, events, history, unlinking from trees)
        # This could be done via events/ Celery tasks.
        return True
    return False

async def add_person_to_tree(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID) -> Optional[Person]:
    """Adds a person to a family tree by adding the tree_id to their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$addToSet": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}}, # $addToSet prevents duplicates
        return_document=ReturnDocument.AFTER
    )
    return Person(**updated_doc) if updated_doc else None

async def remove_person_from_tree(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID) -> Optional[Person]:
    """Removes a person from a family tree by removing the tree_id from their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$pull": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}},
        return_document=ReturnDocument.AFTER
    )
    # After removing, if person.tree_ids is empty, should the person be deleted?
    # This depends on application requirements. For now, just unlinks.
    return Person(**updated_doc) if updated_doc else None


# TODO:
# - Search/filter persons (e.g., by name, dates within a tree)
# - Count persons in a tree
# - Functions for managing facts, identifiers, privacy_settings if they are complex sub-updates.
# - Handling of PersonHistory creation upon updates.
# - CRUD for Person's potential_duplicates, merged_into_id, merged_from_ids.
