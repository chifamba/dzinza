import uuid
from datetime import datetime
from typing import List, Optional, Union

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument

from app.models import Relationship, RelationshipEvent # DB Models
from app.schemas.relationship import RelationshipCreateData, RelationshipUpdateData, RelationshipEventData # API Schemas
from app.db.base import RELATIONSHIPS_COLLECTION

async def create_relationship(
    db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, relationship_in: RelationshipCreateData
) -> Relationship:
    """
    Create a new relationship within a specific family tree.
    """
    collection = db[RELATIONSHIPS_COLLECTION]
    now = datetime.utcnow()

    # Convert RelationshipEventData to RelationshipEvent model instances
    events_in_db_model = [
        RelationshipEvent(**event.model_dump()) for event in relationship_in.events
    ] if relationship_in.events else []

    db_relationship = Relationship(
        **relationship_in.model_dump(exclude={"events"}), # Exclude events as they are handled separately
        tree_id=tree_id,
        events=events_in_db_model, # Assign the converted list
        created_at=now,
        updated_at=now
        # id is generated by default_factory
    )

    # Additional validation or logic based on relationship_type can be added here
    # For example, ensuring parental_role is set if type is PARENT_OF etc.
    # The model itself has some validators, but business logic might be here too.

    await collection.insert_one(db_relationship.model_dump(by_alias=True))
    return db_relationship

async def get_relationship_by_id(
    db: AsyncIOMotorDatabase, *, relationship_id: uuid.UUID, tree_id: Optional[uuid.UUID] = None
) -> Optional[Relationship]:
    """
    Get a relationship by its ID.
    Optionally ensure it belongs to a specific tree_id.
    """
    collection = db[RELATIONSHIPS_COLLECTION]
    query = {"_id": relationship_id}
    if tree_id:
        query["tree_id"] = tree_id

    doc = await collection.find_one(query)
    return Relationship(**doc) if doc else None

async def get_relationships_for_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: Optional[uuid.UUID] = None,
    relationship_type: Optional[str] = None, # Allow filtering by type e.g. models.RelationshipType.SPOUSE
    skip: int = 0, limit: int = 100
) -> List[Relationship]:
    """
    Get all relationships involving a specific person.
    Can be filtered by tree_id and relationship_type.
    """
    collection = db[RELATIONSHIPS_COLLECTION]
    query: dict = {
        "$or": [
            {"person1_id": person_id},
            {"person2_id": person_id}
        ]
    }
    if tree_id:
        query["tree_id"] = tree_id
    if relationship_type:
        query["relationship_type"] = relationship_type

    relationships = []
    cursor = collection.find(query).skip(skip).limit(limit)
    async for doc in cursor:
        relationships.append(Relationship(**doc))
    return relationships

async def count_relationships_for_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: Optional[uuid.UUID] = None,
    relationship_type: Optional[str] = None
) -> int:
    """Counts relationships involving a specific person."""
    collection = db[RELATIONSHIPS_COLLECTION]
    query: dict = {
        "$or": [
            {"person1_id": person_id},
            {"person2_id": person_id}
        ]
    }
    if tree_id:
        query["tree_id"] = tree_id
    if relationship_type:
        query["relationship_type"] = relationship_type
    return await collection.count_documents(query)


async def update_relationship(
    db: AsyncIOMotorDatabase, *, relationship_id: uuid.UUID, relationship_in: RelationshipUpdateData,
    tree_id: Optional[uuid.UUID] = None # To ensure update is within the correct tree context
) -> Optional[Relationship]:
    """
    Update an existing relationship.
    """
    collection = db[RELATIONSHIPS_COLLECTION]

    update_data = relationship_in.model_dump(exclude_unset=True)
    if not update_data:
        return await get_relationship_by_id(db, relationship_id=relationship_id, tree_id=tree_id)

    update_data["updated_at"] = datetime.utcnow()

    # Handle embedded events list: if provided, it's a full replacement
    if relationship_in.events is not None: # Check if 'events' was explicitly provided (even if empty list)
        update_data["events"] = [RelationshipEvent(**event.model_dump()) for event in relationship_in.events]

    query = {"_id": relationship_id}
    if tree_id: # Important for scoped updates
        query["tree_id"] = tree_id

    updated_doc = await collection.find_one_and_update(
        query,
        {"$set": update_data},
        return_document=ReturnDocument.AFTER
    )
    return Relationship(**updated_doc) if updated_doc else None

async def delete_relationship(
    db: AsyncIOMotorDatabase, *, relationship_id: uuid.UUID, tree_id: Optional[uuid.UUID] = None
) -> bool:
    """
    Delete a relationship by its ID.
    Optionally ensure it belongs to a specific tree_id before deletion.
    """
    collection = db[RELATIONSHIPS_COLLECTION]
    query = {"_id": relationship_id}
    if tree_id:
        query["tree_id"] = tree_id

    result = await collection.delete_one(query)
    return result.deleted_count > 0

# TODO:
# - Functions to find specific types of relatives (e.g., get_parents, get_children, get_spouses)
#   These would use get_relationships_for_person with specific relationship_types
#   and then extract the 'other' person_id from the relationship.
# - More complex queries, e.g., finding all relationships within a given tree.
# - Logic to handle reciprocal relationships if needed (e.g., if PARENT_OF is created, is CHILD_OF also created or inferred?)
#   The current model structure with person1_id, person2_id, and type implies direction.
#   For types like SPOUSE or SIBLING_OF, the order of person1/person2 might not matter semantically,
#   but queries would need to check both fields or enforce an order (e.g. person1_id < person2_id).
#   The model validator for Relationship (check_persons_not_same) exists, but no ordering is enforced yet.
