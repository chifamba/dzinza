import uuid
from datetime import datetime, date
from typing import List, Optional, Dict, Any

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument # For find_one_and_update
import structlog # Added for logging task dispatch errors

from app.models_main import Person # DB Model
from app.schemas.person import PersonCreate, PersonUpdate # API Schemas from the new location
from app.db.base import PERSONS_COLLECTION
from app.crud import crud_person_history # Import PersonHistory CRUD operations

logger = structlog.get_logger(__name__) # Define logger

def prepare_for_mongodb(doc_dict: Dict[str, Any]) -> Dict[str, Any]:
    """
    Prepare a document for MongoDB insertion by converting Python objects to MongoDB-compatible types.
    """
    from bson import Binary
    
    # Convert date objects to datetime, UUIDs to Binary, handle nulls
    for key, value in doc_dict.items():
        if isinstance(value, date):
            # Convert date to datetime for MongoDB
            doc_dict[key] = datetime.combine(value, datetime.min.time())
        elif isinstance(value, uuid.UUID):
            # Convert UUID to Binary for MongoDB
            doc_dict[key] = Binary(value.bytes, subtype=4)
        elif isinstance(value, list):
            # Handle lists of UUIDs or other objects
            doc_dict[key] = [
                Binary(item.bytes, subtype=4) if isinstance(item, uuid.UUID) 
                else item for item in value
            ]
        elif isinstance(value, dict):
            # Recursively handle nested dictionaries
            doc_dict[key] = prepare_for_mongodb(value)
        elif value is None:
            # Remove None values to avoid validation errors
            # The validation schema seems to not allow nulls
            continue
    
    # Remove None values from the top level
    doc_dict = {k: v for k, v in doc_dict.items() if v is not None}
    
    return doc_dict

async def create_person(db: AsyncIOMotorDatabase, *, person_in: PersonCreate, creator_user_id: str) -> Person: # Made creator_user_id mandatory
    """
    Create a new person.
    `creator_user_id` might be used for auditing if available.
    """
    collection = db[PERSONS_COLLECTION]
    now = datetime.utcnow()

    db_person_data = person_in.model_dump(exclude_unset=True)

    # Ensure primary_name is an object, even if input was None (model has default_factory)
    if 'primary_name' not in db_person_data:
        db_person_data['primary_name'] = {}

    db_person = Person(
        **db_person_data,
        created_at=now,
        updated_at=now
        # id is generated by default_factory in Person model
        # tree_ids must be provided in person_in as per PersonCreate schema
    )

    # Convert to dict and prepare for MongoDB
    inserted_doc_dict = db_person.model_dump(by_alias=True)
    inserted_doc_dict = prepare_for_mongodb(inserted_doc_dict)
    
    await collection.insert_one(inserted_doc_dict)

    # Log history
    await crud_person_history.log_person_creation(
        db, person_doc=inserted_doc_dict, changed_by_user_id=creator_user_id
    )

    # Trigger duplicate detection task
    try:
        from app.services.tasks import find_duplicate_persons_task
        find_duplicate_persons_task.delay(str(db_person.id))
    except Exception as e:
        # Log error if task dispatch fails, but don't let it fail the CRUD operation
        logger.error(f"Failed to dispatch duplicate detection task for new person {db_person.id}: {e}", exc_info=True)
        pass # Non-critical failure for task dispatch

    return db_person

async def get_person_by_id(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID) -> Optional[Person]:
    """
    Get a person by their ID.
    Privacy/tree access checks should be done at the service/API layer.
    """
    collection = db[PERSONS_COLLECTION]
    doc = await collection.find_one({"_id": person_id})
    return Person(**doc) if doc else None

async def get_persons_by_tree_id(
    db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, skip: int = 0, limit: int = 1000
) -> List[Person]:
    """
    Get all persons belonging to a specific family tree.
    """
    collection = db[PERSONS_COLLECTION]
    persons = []
    cursor = collection.find({"tree_ids": tree_id}).skip(skip).limit(limit)
    async for doc in cursor:
        persons.append(Person(**doc))
    return persons

async def count_persons_by_tree_id(db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID) -> int:
    """Counts persons belonging to a specific family tree."""
    collection = db[PERSONS_COLLECTION]
    return await collection.count_documents({"tree_ids": tree_id})


async def update_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, person_in: PersonUpdate, changed_by_user_id: str
) -> Optional[Person]:
    """
    Update an existing person.
    Access control should be checked at the API layer.
    Logs the update to PersonHistory.
    """
    collection = db[PERSONS_COLLECTION]

    update_data = person_in.model_dump(exclude_unset=True)
    if not update_data: # No actual data to update
        current_person_doc = await collection.find_one({"_id": person_id})
        return Person(**current_person_doc) if current_person_doc else None

    update_data["updated_at"] = datetime.utcnow()

    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$set": update_data},
        return_document=ReturnDocument.AFTER
    )

    if updated_doc:
        await crud_person_history.log_person_update(
            db, person_id=person_id, updated_person_doc=updated_doc, changed_by_user_id=changed_by_user_id
        )

        # Trigger duplicate detection task on significant updates
        # (Define what constitutes a "significant" update - e.g., name, birth date change)
        # For now, triggering on any update.
        try:
            from app.services.tasks import find_duplicate_persons_task
            find_duplicate_persons_task.delay(str(person_id))
        except Exception as e:
            logger.error(f"Failed to dispatch duplicate detection task for updated person {person_id}: {e}", exc_info=True)
            pass

        return Person(**updated_doc)
    return None

async def delete_person(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, changed_by_user_id: str) -> bool:
    """
    Delete a person by their ID (hard delete).
    Logs the deletion to PersonHistory *before* actual deletion.
    IMPORTANT: Cascading deletes for relationships, events etc. must be handled by service layer.
    """
    collection = db[PERSONS_COLLECTION]

    # Fetch the document *before* deletion for logging
    person_to_delete_doc = await collection.find_one({"_id": person_id})
    if not person_to_delete_doc:
        return False # Person not found

    # Log deletion attempt with the current state
    await crud_person_history.log_person_deletion(
        db, person_id=person_id, last_known_person_doc=person_to_delete_doc, changed_by_user_id=changed_by_user_id
    )

    result = await collection.delete_one({"_id": person_id})
    return result.deleted_count > 0

async def add_person_to_tree(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID, changed_by_user_id: str) -> Optional[Person]:
    """Adds a person to a family tree by adding the tree_id to their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$addToSet": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}},
        return_document=ReturnDocument.AFTER
    )
    if updated_doc:
        await crud_person_history.log_person_update(
            db, person_id=person_id, updated_person_doc=updated_doc,
            changed_by_user_id=changed_by_user_id, change_description=f"Added to tree {tree_id}"
        )
        return Person(**updated_doc)
    return None

async def remove_person_from_tree(db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, tree_id: uuid.UUID, changed_by_user_id: str) -> Optional[Person]:
    """Removes a person from a family tree by removing the tree_id from their tree_ids list."""
    collection = db[PERSONS_COLLECTION]
    updated_doc = await collection.find_one_and_update(
        {"_id": person_id},
        {"$pull": {"tree_ids": tree_id}, "$set": {"updated_at": datetime.utcnow()}},
        return_document=ReturnDocument.AFTER
    )

    if updated_doc:
        await crud_person_history.log_person_update(
            db, person_id=person_id, updated_person_doc=updated_doc,
            changed_by_user_id=changed_by_user_id, change_description=f"Removed from tree {tree_id}"
        )
        # Business logic for what happens if tree_ids becomes empty (e.g., delete person?)
        # should be handled at a higher service layer, not in basic CRUD.
        return Person(**updated_doc)
    return None

# Example for searching persons by name (simple regex, can be expanded to use text indexes)
async def search_persons_by_name(
    db: AsyncIOMotorDatabase, *, name_query: str, tree_id: Optional[uuid.UUID] = None, limit: int = 20
) -> List[Person]:
    collection = db[PERSONS_COLLECTION]
    query_filter: Dict[str, Any] = {
        "$or": [
            {"primary_name.given_name": {"$regex": name_query, "$options": "i"}},
            {"primary_name.surname": {"$regex": name_query, "$options": "i"}},
            {"primary_name.nickname": {"$regex": name_query, "$options": "i"}},
            {"alternate_names.given_name": {"$regex": name_query, "$options": "i"}}, # Search in alternate names
            {"alternate_names.surname": {"$regex": name_query, "$options": "i"}},
        ]
    }
    if tree_id:
        query_filter["tree_ids"] = tree_id # Ensure person is in the specified tree

    persons = []
    cursor = collection.find(query_filter).limit(limit)
    async for doc in cursor:
        persons.append(Person(**doc))
    return persons

# TODO:
# - Consider adding functions for managing specific sub-fields if partial updates are complex
#   e.g., add_fact_to_person, update_identifier_for_person.
# - Implement PersonHistory creation within relevant CRUD operations (e.g., after create_person, update_person).
#   This might involve a separate PersonHistory CRUD module.
# - Advanced filtering/querying based on various Person attributes.
