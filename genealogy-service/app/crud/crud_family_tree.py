import uuid
from datetime import datetime
from typing import List, Optional

from motor.motor_asyncio import AsyncIOMotorDatabase

from app.models_main import FamilyTree  # Pydantic model for DB representation
from app.schemas import FamilyTreeCreate, FamilyTreeUpdate  # Pydantic models for API input
from app.db.base import FAMILY_TREES_COLLECTION  # Collection name

async def create_tree(db: AsyncIOMotorDatabase, *, tree_in: FamilyTreeCreate, owner_id: str) -> FamilyTree:
    """
    Create a new family tree for a given owner.
    """
    collection = db[FAMILY_TREES_COLLECTION]

    now = datetime.utcnow()
    db_tree = FamilyTree(
        **tree_in.model_dump(),
        owner_id=owner_id,
        created_at=now,
        updated_at=now
        # id is generated by default_factory in Pydantic model
    )

    await collection.insert_one(db_tree.model_dump(by_alias=True)) # by_alias=True to use '_id'
    return db_tree


async def get_tree_by_id(db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, owner_id: Optional[str] = None) -> Optional[FamilyTree]:
    """
    Get a family tree by its ID.
    If owner_id is provided, it also checks for ownership.
    """
    collection = db[FAMILY_TREES_COLLECTION]
    query = {"_id": tree_id}
    if owner_id:
        query["owner_id"] = owner_id

    doc = await collection.find_one(query)
    return FamilyTree(**doc) if doc else None


async def get_trees_by_owner(
    db: AsyncIOMotorDatabase, *, owner_id: str, skip: int = 0, limit: int = 100
) -> List[FamilyTree]:
    """
    Get all family trees owned by a specific user.
    """
    collection = db[FAMILY_TREES_COLLECTION]
    trees = []
    cursor = collection.find({"owner_id": owner_id}).skip(skip).limit(limit)
    async for doc in cursor:
        trees.append(FamilyTree(**doc))
    return trees

async def update_tree(
    db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, tree_in: FamilyTreeUpdate, owner_id: str
) -> Optional[FamilyTree]:
    """
    Update an existing family tree. Ensures the user owns the tree.
    """
    collection = db[FAMILY_TREES_COLLECTION]

    update_data = tree_in.model_dump(exclude_unset=True) # Only include fields that were set
    if not update_data:
        # If nothing to update, fetch and return current or handle as no-op
        return await get_tree_by_id(db, tree_id=tree_id, owner_id=owner_id)

    update_data["updated_at"] = datetime.utcnow()

    result = await collection.find_one_and_update(
        {"_id": tree_id, "owner_id": owner_id},
        {"$set": update_data},
        return_document=True
    )
    return FamilyTree(**result) if result else None


async def delete_tree(db: AsyncIOMotorDatabase, *, tree_id: uuid.UUID, owner_id: str) -> bool:
    """
    Delete a family tree. Ensures the user owns the tree.
    Returns True if deleted, False otherwise.

    Note: This is a hard delete. Associated persons, relationships, events
    might need to be cleaned up or handled according to application logic
    (e.g., are persons deleted if no longer in any tree? Or just unlinked?).
    For now, this only deletes the tree document itself.
    """
    collection = db[FAMILY_TREES_COLLECTION]
    result = await collection.delete_one({"_id": tree_id, "owner_id": owner_id})
    return result.deleted_count > 0

# TODO: Add function to get total count of trees for an owner (for pagination)
# async def count_trees_by_owner(db: AsyncIOMotorDatabase, *, owner_id: str) -> int:
#     collection = db[FAMILY_TREES_COLLECTION]
#     return await collection.count_documents({"owner_id": owner_id})
