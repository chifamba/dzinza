import uuid
from datetime import datetime
from typing import List, Optional, Dict, Any

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument

from app.models_main import MergeSuggestion, MergeSuggestionStatus # DB Model & Enum
from app.schemas.merge_suggestion import MergeSuggestionCreate # API Schemas
from app.db.base import MERGE_SUGGESTIONS_COLLECTION

async def create_merge_suggestion(
    db: AsyncIOMotorDatabase, *, suggestion_in: MergeSuggestionCreate,
    created_by_user_id: Optional[str] = None, created_by_system: bool = False
) -> MergeSuggestion:
    """
    Create a new merge suggestion.
    Can be created by a user or by the system.
    """
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    now = datetime.utcnow()

    if created_by_user_id and created_by_system:
        raise ValueError("Merge suggestion cannot be created by both user and system simultaneously.")
    if not created_by_user_id and not created_by_system:
        # Default to system if no user provided, or make user mandatory for manual creation
        # For now, let's assume system if no user. Or raise error if clarity is needed.
        created_by_system = True # Or raise ValueError("Creator (user or system) must be specified.")


    db_suggestion = MergeSuggestion(
        **suggestion_in.model_dump(),
        created_by_user_id=created_by_user_id,
        created_by_system=created_by_system,
        status=MergeSuggestionStatus.PENDING, # Always starts as pending
        created_at=now,
        updated_at=now
        # id is generated by default_factory
    )

    # Prevent duplicate pending suggestions for the same pair of persons (order might matter or not)
    # Check if a similar pending suggestion already exists (person1 -> person2 or person2 -> person1)
    existing_pending_suggestion = await collection.find_one({
        "$or": [
            {"new_person_id": db_suggestion.new_person_id, "existing_person_id": db_suggestion.existing_person_id},
            {"new_person_id": db_suggestion.existing_person_id, "existing_person_id": db_suggestion.new_person_id}
        ],
        "status": MergeSuggestionStatus.PENDING
    })
    if existing_pending_suggestion:
        # Return existing or raise error? For now, let's return existing to avoid duplicates.
        # Consider updating confidence if new one is higher.
        return MergeSuggestion(**existing_pending_suggestion)
        # raise ValueError("A pending merge suggestion for these two persons already exists.")


    await collection.insert_one(db_suggestion.model_dump(by_alias=True))

    # TODO: After creating, potentially notify relevant users (e.g., tree owners, person editors)
    # This would involve calling crud_notification.create_notification

    return db_suggestion

async def get_suggestion_by_id(db: AsyncIOMotorDatabase, *, suggestion_id: uuid.UUID) -> Optional[MergeSuggestion]:
    """Get a merge suggestion by its ID."""
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    doc = await collection.find_one({"_id": suggestion_id})
    return MergeSuggestion(**doc) if doc else None

async def get_suggestions_for_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID,
    status: Optional[MergeSuggestionStatus] = None,
    skip: int = 0, limit: int = 50
) -> List[MergeSuggestion]:
    """Get all merge suggestions involving a specific person (as either new or existing)."""
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    query: Dict[str, Any] = {
        "$or": [
            {"new_person_id": person_id},
            {"existing_person_id": person_id}
        ]
    }
    if status:
        query["status"] = status

    suggestions = []
    cursor = collection.find(query).sort("created_at", -1).skip(skip).limit(limit)
    async for doc in cursor:
        suggestions.append(MergeSuggestion(**doc))
    return suggestions

async def count_suggestions_for_person(
    db: AsyncIOMotorDatabase, *, person_id: uuid.UUID, status: Optional[MergeSuggestionStatus] = None
) -> int:
    """Counts merge suggestions involving a specific person."""
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    query: Dict[str, Any] = {
        "$or": [
            {"new_person_id": person_id},
            {"existing_person_id": person_id}
        ]
    }
    if status:
        query["status"] = status
    return await collection.count_documents(query)

async def get_pending_suggestions(
    db: AsyncIOMotorDatabase, *, tree_id: Optional[uuid.UUID] = None, # If suggestions are tree-scoped
    skip: int = 0, limit: int = 100
) -> List[MergeSuggestion]:
    """
    Get all pending merge suggestions.
    Optionally filter by tree_id if suggestions are linked to trees (e.g., via persons involved).
    This requires suggestions or persons to have tree_id information accessible for filtering.
    For now, assuming global pending suggestions, or tree scoping needs to be added to MergeSuggestion model or person lookup.
    """
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    query: Dict[str, Any] = {"status": MergeSuggestionStatus.PENDING}

    # If tree_id is provided, this gets complex as MergeSuggestion doesn't directly store tree_id.
    # Would need to join/lookup persons involved and check their tree_ids.
    # This is a simplified version without tree_id filtering for now.
    # if tree_id:
    #     # This would require a more complex aggregation query
    #     pass

    suggestions = []
    cursor = collection.find(query).sort("confidence", -1).skip(skip).limit(limit) # Sort by confidence
    async for doc in cursor:
        suggestions.append(MergeSuggestion(**doc))
    return suggestions


async def update_suggestion_status(
    db: AsyncIOMotorDatabase, *, suggestion_id: uuid.UUID, status: MergeSuggestionStatus,
    updated_by_user_id: str # User who accepted/declined
) -> Optional[MergeSuggestion]:
    """
    Update the status of a merge suggestion (e.g., to accepted or declined).
    """
    collection = db[MERGE_SUGGESTIONS_COLLECTION]

    # Ensure suggestion is currently pending before updating
    current_suggestion = await collection.find_one({"_id": suggestion_id, "status": MergeSuggestionStatus.PENDING})
    if not current_suggestion:
        return None # Not found or not in a state that can be updated by this function

    update_data = {
        "status": status,
        "updated_at": datetime.utcnow()
        # Optionally log who updated it, if not relying on audit logs from API layer
        # "processed_by_user_id": updated_by_user_id (if added to model)
    }

    updated_doc = await collection.find_one_and_update(
        {"_id": suggestion_id}, # Query by ID, status check already done
        {"$set": update_data},
        return_document=ReturnDocument.AFTER
    )

    if updated_doc and status == MergeSuggestionStatus.ACCEPTED:
        # TODO: Trigger actual merge logic here or via a Celery task.
        # This involves merging data from new_person_id into existing_person_id,
        # updating relationships, marking new_person_id as merged, etc.
        # For now, just updating status.
        pass

    return MergeSuggestion(**updated_doc) if updated_doc else None

async def delete_suggestion(db: AsyncIOMotorDatabase, *, suggestion_id: uuid.UUID) -> bool:
    """Delete a merge suggestion (e.g., if it's invalid or a system cleanup)."""
    collection = db[MERGE_SUGGESTIONS_COLLECTION]
    result = await collection.delete_one({"_id": suggestion_id})
    return result.deleted_count > 0

# Note: Actual person data merging logic is complex and would typically reside in a service layer,
# potentially triggered after a suggestion is 'accepted'. This CRUD module focuses on the suggestion document itself.
