import uuid
from datetime import datetime
from typing import List, Optional, Dict, Any

from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo import ReturnDocument

from app.models_main import Notification # DB Model
# Schemas might be used if creating notifications via API, but often they are system-generated.
# from app.schemas.notification import NotificationCreate # If users can create them
from app.db.base import NOTIFICATIONS_COLLECTION # Collection name, to be defined in base.py

async def create_notification(
    db: AsyncIOMotorDatabase, *, user_id: str, type: str, message: str, data: Optional[Dict[str, Any]] = None
) -> Notification:
    """
    Create a new notification for a user.
    Typically called by other service logic (e.g., after a merge suggestion is created).
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    now = datetime.utcnow()

    db_notification = Notification(
        user_id=user_id,
        type=type,
        message=message,
        data=data,
        read=False, # Notifications start as unread
        created_at=now,
        updated_at=now # same as created_at initially
        # id is generated by default_factory
    )

    await collection.insert_one(db_notification.model_dump(by_alias=True))
    return db_notification

async def get_notification_by_id(
    db: AsyncIOMotorDatabase, *, notification_id: uuid.UUID, user_id: str # Ensure user owns notification
) -> Optional[Notification]:
    """
    Get a specific notification by its ID, ensuring it belongs to the user.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    notification_id_str = str(notification_id)
    doc = await collection.find_one({"_id": notification_id_str, "user_id": user_id})
    return Notification(**doc) if doc else None

async def get_notifications_for_user(
    db: AsyncIOMotorDatabase, *, user_id: str,
    read_status: Optional[bool] = None, # Filter by read/unread
    skip: int = 0, limit: int = 50 # Default limit for notifications often smaller
) -> List[Notification]:
    """
    Get notifications for a specific user.
    Can be filtered by read_status.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    query: Dict[str, Any] = {"user_id": user_id}
    if read_status is not None:
        query["read"] = read_status

    notifications = []
    # Typically, notifications are shown newest first
    cursor = collection.find(query).sort("created_at", -1).skip(skip).limit(limit)
    async for doc in cursor:
        notifications.append(Notification(**doc))
    return notifications

async def count_notifications_for_user(
    db: AsyncIOMotorDatabase, *, user_id: str, read_status: Optional[bool] = None
) -> int:
    """
    Count notifications for a user, optionally filtered by read_status.
    Useful for badges (e.g., unread count).
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    query: Dict[str, Any] = {"user_id": user_id}
    if read_status is not None:
        query["read"] = read_status
    return await collection.count_documents(query)

async def mark_notification_as_read(
    db: AsyncIOMotorDatabase, *, notification_id: uuid.UUID, user_id: str
) -> Optional[Notification]:
    """
    Mark a specific notification as read. Ensures user owns the notification.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    # Convert UUID to string for MongoDB query
    notification_id_str = str(notification_id)
    updated_doc = await collection.find_one_and_update(
        {"_id": notification_id_str, "user_id": user_id, "read": False}, # Only update if currently unread
        {"$set": {"read": True, "updated_at": datetime.utcnow()}},
        return_document=ReturnDocument.AFTER
    )
    if updated_doc:
        return Notification(**updated_doc)
    # If not updated (e.g. already read or not found), fetch current state
    return await get_notification_by_id(db, notification_id=notification_id, user_id=user_id)


async def mark_all_notifications_as_read_for_user(
    db: AsyncIOMotorDatabase, *, user_id: str
) -> int:
    """
    Mark all unread notifications for a user as read.
    Returns the number of notifications updated.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    result = await collection.update_many(
        {"user_id": user_id, "read": False},
        {"$set": {"read": True, "updated_at": datetime.utcnow()}}
    )
    return result.modified_count

async def delete_notification(
    db: AsyncIOMotorDatabase, *, notification_id: uuid.UUID, user_id: str
) -> bool:
    """
    Delete a specific notification. Ensures user owns the notification.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    notification_id_str = str(notification_id)
    result = await collection.delete_one({"_id": notification_id_str, "user_id": user_id})
    return result.deleted_count > 0

async def delete_all_notifications_for_user(
    db: AsyncIOMotorDatabase, *, user_id: str, only_read: Optional[bool] = None
) -> int:
    """
    Delete all notifications for a user.
    Can optionally delete only read notifications.
    Returns the number of notifications deleted.
    """
    collection = db[NOTIFICATIONS_COLLECTION]
    query: Dict[str, Any] = {"user_id": user_id}
    if only_read is not None:
        query["read"] = only_read # if only_read is True, delete read ones. If False, delete unread.
                                  # if None, delete all.

    result = await collection.delete_many(query)
    return result.deleted_count
